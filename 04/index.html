<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        /* background-color:#000; */
        /* background: url('https://cs460.org/assignments/04/bg.jpg'); */
        background-size: cover;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
      #coral-reef{
        position: fixed;
        margin: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
      }
      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform vec3 u_offset;

    uniform float u_pointsize;

    uniform mat4 u_transform;

    void main(void) {
    
      vec4 final_position = u_transform * vec4(a_position, 1.);
      gl_Position = final_position;
      gl_PointSize = u_pointsize;
    
    }
  </script>
  
  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;

    window.onload = function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );


      // create multiple rectangles
      all_fish = [];
      all_fish.push(createFish( [0, 0, 0], [1,0,0,1], 1, -1));
      for(i = 0; i < 100; i++){
        random_color = [Math.random(),Math.random(),Math.random(),Math.random()];
        random_offset = [Math.random()-Math.random(),Math.random()-Math.random(), 0];
        random_scale = Math.random()*.5;
        all_fish.push(createFish(random_offset, random_color, random_scale, 1));
      }
      //rectangles.push( createRectangle( new Float32Array([0,0,0]), new Float32Array([1.,0.,0.,1.]) ) );


      animate();

    };


    function createFish(offset, color, scale, direction) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
    //   var vertices = new Float32Array( [
    //                                  -0.5,  0.5, 0.0, // 0: V0
    //                                  -0.5, -0.5, 0.0, // 1: V1, V4
    //                                   0.5,  0.5, 0.0, // 2: V2, V3
    //                                   0.5, -0.5, 0.0  // 3: V5
    //                                 ] ); // 2 * 4 == 8 bytes
    var vertices = new Float32Array( [
        0.5, 0.0, 0.0, //0 nose
        0.2, 0.25, 0.0, //1 upper body
        -0.2, 0.15,0.0, //2 upper tail
        -0.4, 0.3, 0.0, //3 upper tail
        -0.4, -0.3, 0.0, //4 lower tail
        -0.2, -0.15, 0.0, //5 lower tail
        0.2, -0.25, 0.0 //6 body
    ]);

      // now use indices
      //var indices = new Uint8Array( [ 0, 1, 2, 2, 1, 3 ] ); // 6 bytes
    var indices = new Uint8Array([0,1,6,
                                  1,2,6,
                                  2,5,6,
                                  2,3,5,
                                  3,4,5
                                ]);
    if(direction == 1){
        var eye_vertex = new Float32Array([ 0.2, 0.2, 0.0 ]);
    }
    if(direction == -1){
        var eye_vertex = new Float32Array([ 0.2, -0.2, 0.0 ]);
    }
    eye_v_buffer = gl.createBuffer();
    gl.bindBuffer( gl.ARRAY_BUFFER, eye_v_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind


      return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];

    };

    
    var step_x = .01;
    var step_y = .01;
    var direction = -1;

    //keeps track of the x,y,direction of the red fish
    var red_fish_offset = [0,0];

    window.onkeypress = function(e) {
      var move_scale = 0.05;
      if(e.key == 'a'){
        red_fish_offset[0]+= move_scale;
      } else if(e.key == 'd'){
        red_fish_offset[0] -= move_scale;
      } else if(e.key == 'w'){
        red_fish_offset[1] += move_scale;
      } else if(e.key == 's'){
        red_fish_offset[1] -= move_scale;
      }
    }
    function animate() {

      requestAnimationFrame(animate);

      gl.clearColor( 0., 0., 0., 0.)
      gl.clear( gl.COLOR_BUFFER_BIT );



      for( var r = 0; r < all_fish.length; r++ ) {

        // current_buffers is a list of [v_buffer, i_buffer]-pairs
        var current_buffers = all_fish[r];
        var current_v_buffer = current_buffers[0];
        var current_i_buffer = current_buffers[1];
        var current_eye_v_buffer = current_buffers[2]; //added
        var current_color = current_buffers[3];
        var current_offset = current_buffers[4];
        var current_scale = current_buffers[5];
        var current_direction = current_buffers[6]

        if(r == 0){
          current_offset[0] = red_fish_offset[0];
          current_offset[1] = red_fish_offset[1];
        } else{
        // update offsets
        current_offset[0] += 0.01;
        current_offset[1] += 0.1*Math.random();
        current_offset[1] -= 0.1*Math.random();
        }
        if(current_offset[0] >= 1){
            current_direction = -1;
        }
        current_offset[0] *= current_direction;
        
        theta = Math.random()*10 * Math.PI/180;
        scale = 0.5
        transform = [
           current_scale*current_direction*Math.cos(theta),Math.sin(theta),0,0,
            -Math.sin(theta),current_scale*current_direction*Math.cos(theta),0,0,
            0,0,current_scale*current_direction*1,0,
            current_offset[0],current_offset[1],current_offset[2],1];

        //************************************************************//
        //
        // CONNECT SHADER WITH GEOMETRY
        //
        
        gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );

        // find the attribute in the shader source
        var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );

        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );

        gl.enableVertexAttribArray ( a_position );

        // find the uniform in the shader source
        //var u_offset = gl.getUniformLocation( shaderprogram, 'u_offset' );
        var u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
        gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));
        //gl.uniform3fv( u_offset, current_offset)

        var u_color = gl.getUniformLocation( shaderprogram, 'u_color' );
        
        t = performance.now() * 0.001;
        a = 0.6 + 0.4 * Math.sin(t * 2.0);
        current_color = new Float32Array([
            0.3 + 0.2*Math.sin(t + 0.0),
            0.6 + 0.2*Math.sin(t + 2.0),
            0.9 + 0.1*Math.sin(t + 4.0),
            a
        ]);
        if(r == 0){
            current_color = [1,0,0,.7];
        }
        gl.uniform4fv( u_color, current_color );

        //************************************************************//
        //
        // DRAW!
        //


        // gl.drawArrays( gl.TRIANGLES, 0, 6 );
        gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

        gl.uniform4fv(u_color, new Float32Array([0,0,0,.5]));
        u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
        gl.uniform1fv(u_pointsize, new Float32Array([current_scale*20.]));

        gl.enableVertexAttribArray(a_position);
        gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_v_buffer);

        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_position);

        gl.drawArrays(gl.POINTS, 0, 1);

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        gl.disable(gl.DEPTH_TEST);
      }


    };

  </script>
  <body>
    <video autoplay muted loop id="coral-reef">
      <source src="coral-reef.mp4" type="video/mp4">
    </video>
    <canvas id="c"></canvas>
  </body>
</html>
